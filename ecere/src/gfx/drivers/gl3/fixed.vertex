#version 100

uniform mat4 projection_matrix;
uniform mat4 modelview_matrix;
uniform mat4 normals_matrix;
uniform vec4 current_color;

// Lights
uniform bool lightsOn[8];
uniform vec4 lightsPos[8];
uniform float lightsKc[8];
uniform float lightsKl[8];
uniform float lightsKq[8];

uniform vec3 lightsSpotDir[8];
uniform bool lightsSpot[8];
uniform float lightsSpotCutOffCos[8];
uniform float lightsSpotExp[8];

uniform vec3 lightsDiffuse[8];
uniform vec3 lightsAmbient[8];
uniform vec3 lightsSpecular[8];

uniform vec3 globalAmbient;
uniform bool lightingOn;
uniform float nearPlane;

// Material
uniform bool perVertexColor;
uniform vec3 matDiffuse;
uniform vec3 matAmbient;
uniform vec3 matSpecular;
uniform vec3 matEmissive;
uniform float matOpacity;
uniform float matPower;
uniform bool matTwoSided;

// Fog
uniform bool fogOn;
uniform float fogDensity;
uniform vec3 fogColor;

attribute vec2 texCoord;
attribute vec3 vertex;
attribute vec3 normal;
attribute vec4 color;

varying vec2 fTexCoord;
varying vec4 fColor;
varying vec4 fColorBack;
varying vec3 fSpec;
varying vec3 fSpecBack;

void main(void)
{
   float f = 1.0;
   vec3 n = normalize(mat3(normals_matrix) * normal);
   // float z = dot(mvmatrix_z, vec4(vertex, 1.0));
   vec4 pos = modelview_matrix * vec4(vertex, 1.0);
   vec3 pos3 = pos.xyz;

   // gl_Position = proj_modelview_matrix * vec4(vertex, 1.0);
   gl_Position = projection_matrix * pos;

   fTexCoord = texCoord;

   if(fogOn)
      f = clamp(exp(fogDensity * pos3.z), 0.0, 1.0);

   if(lightingOn)
   {
      vec3 diffuseColor = perVertexColor ? color.xyz : matDiffuse;
      vec3 ambientColor = perVertexColor ? color.xyz : matAmbient;
      float opacity     = perVertexColor ? color.w   : matOpacity;
      vec3 eye = vec3(0.0, 0.0, 1.0);
      //vec3 eye = normalize(-pos3*nearPlane); // For Local Viewer
      vec3 diffuse = vec3(0), diffuseBack = vec3(0), specular = vec3(0), specularBack = vec3(0), ambient = vec3(0);
      for(int i = 0; i < 8; i++)
         if(lightsOn[i])
         {
            vec3 l = lightsPos[i].xyz - (lightsPos[i].w == 0.0 ? vec3(0) : pos3 * nearPlane);
            float d = length(l);
            float nDotL;
            float pf = 0.0;
            vec3 halfWay;
            float attenuation = 1.0;

            l /= d;
            nDotL = max(0.0, dot(n, l));

            halfWay = normalize(l + eye);
            if(nDotL != 0.0) //> 0.0001)
            {
               float nDotHV = max(0.0, dot(n, halfWay));
               pf = (matPower < 0.1) ? 1.0 : pow(nDotHV, matPower);
            }

            if(lightsPos[i].w > 0.0001)
            {
               if(lightsSpot[i])
               {
                  float spotDot = dot(l, lightsSpotDir[i]);
                  attenuation = (spotDot < lightsSpotCutOffCos[i]) ? 0.0 : pow(max(0.0, spotDot), lightsSpotExp[i]);
               }
               attenuation /= (lightsKc[i] + lightsKl[i] * d + lightsKq[i] * d * d);
            }

            ambient  += lightsAmbient [i] * attenuation;
            diffuse  += lightsDiffuse [i] * attenuation * nDotL;
            specular += lightsSpecular[i] * attenuation * pf;

            if(matTwoSided)
            {
               vec3 iN = -n;
               float inDotL = min(1.0, max(0.0, dot(iN, l)));
               if(inDotL > 0.0001)
               {
                  float nDotHV = max(0.0, dot(iN, halfWay));
                  pf = (matPower < 0.1) ? 1.0 : pow(nDotHV, matPower);
               }

               diffuseBack  += lightsDiffuse [i] * attenuation * inDotL;
               specularBack += lightsSpecular[i] * attenuation * pf;
            }
         }

      ambient = ambientColor * (ambient + globalAmbient);
      //fColor = vec4(min(vec3(1.0), diffuseColor * diffuse + matSpecular * specular + matEmissive + ambient), opacity);
      fColor = vec4(min(vec3(1.0), diffuseColor * diffuse + matEmissive + ambient), opacity);
      fSpec = min(vec3(1.0), matSpecular * specular);

      if(matTwoSided)
      {
         // fColorBack = vec4(min(vec3(1.0), diffuseColor * diffuseBack + matSpecular * specularBack + matEmissive + ambient), opacity);
         fColorBack = vec4(min(vec3(1.0), diffuseColor * diffuseBack + matEmissive + ambient), opacity);
         fSpecBack = min(vec3(1.0), matSpecular * specularBack);
         if(fogOn)
            fColorBack = f * fColorBack + (1.0-f) * vec4(fogColor, 1);
      }
   }
   else
      fColor = current_color * (perVertexColor ? color : vec4(1.0));

   if(fogOn)
      fColor = f * fColor + (1.0-f) * vec4(fogColor, 1);
}
